== Selectors

The _selection language_ defines a compact language to select nodes and node
sets (lists of nodes) in a tree. It is inspired by languages such as
[XPath],[jQuery selectors] and [treepace].

The selection language is actually two mini languages combined together: the
selection language which defines selections of nodes, and the constraints/production
languages


```

```

Model
===== 

Node, Attribute

Selection::

	- axis
	- path
	- constraint

Constraint::

	A constraint is the invocation of a function with arguments that
	can be arbitrary values, selections and functions. The constraint
	language is a purely functional typed mini-language.

Production::


	A production is a function that is used to generate the result of
	a selection.

Binding::

	- name
	- value

Values::

	- reference
	- node name
	- node name patteran
	- string litterals
	- numeric litterals


Representation
===============

Axes
----

The axes are denoted with `/` (children), `\` (parent), `>` (next siblings) and
`<` (previous siblings). The axes are shallowed unless they are doubles `//`
(descendants), `\\` (ancestors), etc.

Parent::

	Selects the parent, returning  a `Node` or `Nothing`

	```
	\                           ;; the current parent
	\node                       ;; the parent if it has the name `node`
	\*\node                     ;; the grand parent with a node name
	```

ancetors (`:NodeSet`)::

	```
	\\*                         ;; any ancestor
	```

children::

	```
	/
	```

	```
	/.
	```

descendants::

	```
	//
	```

	```
	//.
	```

siblings::

	```
	<.
	```

	```
	>.
	```

	```
	<>
	```

	```
	<>.
	```

adjacent subtrees::

	The following indicates all the nodes that come before the current
	node in a depth-first traversal.

	```
	<<
	```

	```
	<<.
	```


	The following indicates all the nodes that come after the current
	node in a depth-first traversal.

	```
	>>
	```

	```
	>>.
	```



It is possible to constrain the depth of the selection by adding a number
inbetween the symbols. The following will limit to the descendants up to
depth 2 (grand children).

```
/2/
```

Special values
--------------

current node::

	`.`

parent node::

	`..`

root node::

	`:`

any node::

	`*`

a node with a name that starts with `node-`::

	'node-*'

current attribute::

	`@`

Attributes
----------

Attributes can be selected using `@`

Functions
---------

The selector has strongly typed polymorphic functions.

Position::

- `nth(n:Node)`
- `count(n:NodeSet)`
- `count(t:Tree)`
- `depth(n:Node)`
- `depth(t:Tree)`

Predicates::

- `is()`
- `in(s:NodeSet,n:Node)`
- `has()`
- `not()`
- `eq()`
- `lt()`
- `lte()`
- `gt()`
- `gte()`


Combinators::

- `union(a:NodeSet,b:NodeSet)`
- `difference(a:NodeSet,b:NodeSet)`
- `intersection(a:NodeSet,b:NodeSet)`

Extractors::

- `first(a:NodeSet)`, return the first, or nothing
- `last(a:NodeSet):Node|Nothing`, returns a node, or nothing
- `head(a:NodeSet):Node|Nothing`
- `tail(a:NodeSet):NodeSet`
- `nodes(a:Node):NodeSet`, converts the node to a node set.
- `nodes(a:Tree):NodeSet`, converts all the nodes in the tree to a node-set

Filtering and matching::

- `filter()`
- `match()`

Subexpressions
--------------

Any selector expression can be constrained using `[…]`.

```
example[eq(@type,"test")]
```

Variables
---------

Any selection or invocation can be wrapped in a variable binding and 
later user using a variable reference. For instance

```selector
{BEFORE:<*}{AFTER:>*}{SIBLINGS:union($BEFORE,$AFTER)}/
```

Bindings are expressions wrappend in `{…}`, optionally prefixed with
the binding name (in `UPPER_CASE`). Bindings *won't affect the scope*, unless
they are used in a function invocation or suffixed by a path selector.

```selector
{./*}          ;; Implicit binding, bound to 0
{CHILDREN:./*} ;; Explicit binding
```

You can simulate a sequential execution by chaining bindings:

```
;; Returns the list of children (it's very contrived!)
{CHILDREN:./*}{//[in($CHILDREN,.)}
```

Examples
--------

```tree
(scope
	(define 'a 1)
	(scope
		(if ('> (ref 'a) 0))))
```

The following Selects any `ref` node in the tree, stores the `ref` attribute value as NAME,
and the select any preceding node in the traversal that is a `define`
 node with the `ref` attribute equal to the given `$NAME`. If there is
 no node like that, it means that the reference cannot be resolved.

```selector
.//ref/{NAME:@ref}[empty(.<<define/@ref[eq(@,$NAME)]]
```


References
==========

- [XPath]:<https://en.wikipedia.org/wiki/XPath>. XPath is a very powerful and
  complete selection language that is part of the XML/XSLT toolkit. While it's
  relatively popular, it has a few usability issues. 

- [jQuery selectors]:<https://api.jquery.com/category/selectors/>. jQuery
  selectors is a superset of CSS selectors that incorporate some of XPath's
  syntax. It is quite intuitive to pick up, but lacks the advanced capabilities
  of XPath such as axes.

- [treepace]:<https://github.com/sulir/treepace> features a compact and versatile
  selection language, that has the interesting property of being symmetric, ie.
  the  `A < B` and `B > A` both mean "A is a parent of B", which makes
  it possible to write complex selections: `a < b <c>, d`. Treepace also
  introduces the notion of implicit groups that allows for building
  more comple expressions by combingin results.
